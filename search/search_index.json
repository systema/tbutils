{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to tbutils Develop IIoT Applications at ease with ThingBoard An Java/Kotlin library of utilities for IIoT applications using the ThingsBoard IoT platform . It's built on top of the ThingsBoard Java Client , its websocket and mqtt interface. What's in the box? Improved Connectivity - Connect to ThingsBoard via REST and websockets to receive device updates and send data back to ThingsBoard Device Autodiscovery - discovery of active devices Autoconfiguration of IoT Application - Streamline application development, but letting an application configure TB including dashboards, profiles, rule-chains and all other entities User Management - Create tenants, users, and make sure a TB deployment is secure Entity Management - Allows managing TB entities programmatically at ease without using the web UI. tb-utils is intentionally opionatied to enforce best-practices and robust IIoT applications. Getting Started Nothing can beat a good example. So feel welcome to explore the vibration monitoring example application to learn about how tb-utils can help to streamline IIoT application development. How to contribute? Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-) Support Feel welcome to post questions and ideas in the project's discussion forum Sponsor tbutils is devloped and sponsored by SYSTEMA - Art of Automation GmbH .","title":"Introduction"},{"location":"#welcome-to-tbutils","text":"Develop IIoT Applications at ease with ThingBoard An Java/Kotlin library of utilities for IIoT applications using the ThingsBoard IoT platform . It's built on top of the ThingsBoard Java Client , its websocket and mqtt interface.","title":"Welcome to tbutils"},{"location":"#whats-in-the-box","text":"Improved Connectivity - Connect to ThingsBoard via REST and websockets to receive device updates and send data back to ThingsBoard Device Autodiscovery - discovery of active devices Autoconfiguration of IoT Application - Streamline application development, but letting an application configure TB including dashboards, profiles, rule-chains and all other entities User Management - Create tenants, users, and make sure a TB deployment is secure Entity Management - Allows managing TB entities programmatically at ease without using the web UI. tb-utils is intentionally opionatied to enforce best-practices and robust IIoT applications.","title":"What's in the box?"},{"location":"#getting-started","text":"Nothing can beat a good example. So feel welcome to explore the vibration monitoring example application to learn about how tb-utils can help to streamline IIoT application development.","title":"Getting Started"},{"location":"#how-to-contribute","text":"Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-)","title":"How to contribute?"},{"location":"#support","text":"Feel welcome to post questions and ideas in the project's discussion forum","title":"Support"},{"location":"#sponsor","text":"tbutils is devloped and sponsored by SYSTEMA - Art of Automation GmbH .","title":"Sponsor"},{"location":"about/","text":"About License tbutils is licensed under MIT License. Acknowledgements TBD Repo Maintainers See http://systema.com Axel Wogawa {tbd} Rakesh Ganya {tbd} Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#license","text":"tbutils is licensed under MIT License.","title":"License"},{"location":"about/#acknowledgements","text":"TBD","title":"Acknowledgements"},{"location":"about/#repo-maintainers","text":"See http://systema.com Axel Wogawa {tbd} Rakesh Ganya {tbd} Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science.","title":"Repo Maintainers"},{"location":"architecture/","text":"tbutils provides different APIs to streamline IIoT application development. Device Auto-Discovery tb-utils allows to discover all devices of a given device profile registered with ThingsBoard, grouped into active and inactive devices. A device is active, if its SERVER_SCOPE attribute active is currently true . // action to handle discovered active devices var activeAction = new Consumer < List < Device >> (){ @Override public void accept ( List < Device > activeDevices ){ for ( Device dev : activeDevices ){ System . out . println ( \"Found active device \" + dev . getName ()); // open websocket connection to receive attribute /telemetry events, create handlers etc. } } }; // action to handle discovered inactive devices var inactiveAction = new Consumer < List < Device >> (){ @Override public void accept ( List < Device > inactiveDevices ){ for ( Device dev : inactiveDevices ){ System . out . println ( \"Found inactive device \" + dev . getName ()); // close open connections, remove handlers etc. } } }; // start discovery and schedule it to run every 20s var discoveryTask = new DeviceDiscovery ( tbRestClient , deviceProfile , activeAction , inactiveAction ); var executor = Executors . newScheduledThreadPool ( 1 ); executor . scheduleAtFixedRate ( discoveryTask , 0 , 20 , TimeUnit . SECONDS ); Device Twin A tbutils DeviceTwin keep a local copy of ThingsBoard device attributes: val twin = DeviceTwin ( device ) client . subscribeToWS ( device . id , SubscriptionType . SHARED_SCOPE ) { updates -> updates . forEach { twin . update ( SubscriptionType . SHARED_SCOPE , it ) } } Simplified Entity Management Find entities in ThingsBoard with com.systema.eia.iot.tb.persistence.search.TbFinder getById() - by id getByName() - by name getAll() - all of them within a tenant Java example: ExtRestClient client = new ExtRestClient ( tbUrl ); TbFinder finder = new ExtRestClient ( client ); RuleChain rulChain = finder . getRuleChain (). getByName ( \"my rule chain\" ); Delete entities in ThingsBoard with com.systema.eia.iot.tb.persistence.remove.TbRemover findAndRemoveByName() - by name findAndRemoveById() - by entity id Kotlin example val remover = TbRemover ( TB_URL ) remover . device . findAndRemoveByName ( \"my device\" ) remover . device . findAndRemoveById ( \"<eniity id>\" )","title":"Architecture"},{"location":"architecture/#device-auto-discovery","text":"tb-utils allows to discover all devices of a given device profile registered with ThingsBoard, grouped into active and inactive devices. A device is active, if its SERVER_SCOPE attribute active is currently true . // action to handle discovered active devices var activeAction = new Consumer < List < Device >> (){ @Override public void accept ( List < Device > activeDevices ){ for ( Device dev : activeDevices ){ System . out . println ( \"Found active device \" + dev . getName ()); // open websocket connection to receive attribute /telemetry events, create handlers etc. } } }; // action to handle discovered inactive devices var inactiveAction = new Consumer < List < Device >> (){ @Override public void accept ( List < Device > inactiveDevices ){ for ( Device dev : inactiveDevices ){ System . out . println ( \"Found inactive device \" + dev . getName ()); // close open connections, remove handlers etc. } } }; // start discovery and schedule it to run every 20s var discoveryTask = new DeviceDiscovery ( tbRestClient , deviceProfile , activeAction , inactiveAction ); var executor = Executors . newScheduledThreadPool ( 1 ); executor . scheduleAtFixedRate ( discoveryTask , 0 , 20 , TimeUnit . SECONDS );","title":"Device Auto-Discovery"},{"location":"architecture/#device-twin","text":"A tbutils DeviceTwin keep a local copy of ThingsBoard device attributes: val twin = DeviceTwin ( device ) client . subscribeToWS ( device . id , SubscriptionType . SHARED_SCOPE ) { updates -> updates . forEach { twin . update ( SubscriptionType . SHARED_SCOPE , it ) } }","title":"Device Twin"},{"location":"architecture/#simplified-entity-management","text":"Find entities in ThingsBoard with com.systema.eia.iot.tb.persistence.search.TbFinder getById() - by id getByName() - by name getAll() - all of them within a tenant Java example: ExtRestClient client = new ExtRestClient ( tbUrl ); TbFinder finder = new ExtRestClient ( client ); RuleChain rulChain = finder . getRuleChain (). getByName ( \"my rule chain\" ); Delete entities in ThingsBoard with com.systema.eia.iot.tb.persistence.remove.TbRemover findAndRemoveByName() - by name findAndRemoveById() - by entity id Kotlin example val remover = TbRemover ( TB_URL ) remover . device . findAndRemoveByName ( \"my device\" ) remover . device . findAndRemoveById ( \"<eniity id>\" )","title":"Simplified Entity Management"},{"location":"changes/","text":"Changes See https://github.com/systema/tbutils/changes.md","title":"What's New?"},{"location":"changes/#changes","text":"See https://github.com/systema/tbutils/changes.md","title":"Changes"},{"location":"configuration/","text":"ThingsBoard Auto-Configuration The library provides mean to streamline ThingsBoard configuration (e.g. devices, rule chains, dashboards). Instead of configuring ThingsBoard separately, it allows doing so within the tb-utils application itself. This provides multiple benefits: Reduced deployment effort Streamlined maintenance path, where a new release of an application will also roll out necessary TB configuration changes (e.g. schema, rule-chain or dashboard improvements) The API also supports merging configuration changes into a running system by There are 2 dedicated functions, that a developer can instrument to enable application backup and restore. Backup - Download ThingsBoard entities and save them as json files Upload - Restore previously persisted entities Backup and restore are available for all major TB entity types. See here for a fully worked out example. Backup This is typically performed after TB has been configured via the web UI, and all relevant settings should be packaged for deployment. TbBackup backup = new TbBackup ( restClient ); TbConfigPaths configPaths = new TbConfigPaths ( \"tbconfig\" ); backup . getDeviceProfile (). save ( System . getenv ( \"DEVICE_PROFILE\" ), configPaths . profilesPath ); backup . getRuleChain (). save ( \"Vibration Root Rule Chain\" , configPaths . rulesPath ); backup . getWidgetBundle (). save ( \"Systema Widgets\" , configPaths . widgetsBundlePath ); backup . getWidget (). save ( \"Systema Widgets\" , \"Change Device\" , configPaths . widgetsPath ); backup . getDashboard (). save ( \"Vibration CM\" , configPaths . dashboardsPath ); This will store the entities as json in a user-defined resource directory within the application. So essentially, the user only needs to declare which entities belong to the application and should be persisted. Upload Later on during deployment or application update, the persisted entities can be restored/updated using an inverse procedure: ConfigUploader uploader = new ConfigUploader ( client ); uploader . getDeviceProfile (). loadAll ( \"path/to/my-device-profile.json\" ); uploader . getDashboard (). load ( \"path/to/my-dashboard.json\" ); Entity Path Model The config files that tb-utils can deal with are json files created either via the ThingsBoard web UI export functionality or by using the tb-utils backup feature. For easier config file handling, there is a utility class structuring the config files in the following way (or a subset thereof): var configPaths = new TbConfigPaths ( \"config/root/dir/\" ); This would create a file structure like this: config/root/dir/ \u251c\u2500\u2500 assets \u2502 \u2514\u2500\u2500 xxx.json \u251c\u2500\u2500 bundles \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 customers \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 dashboards \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 devices \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 profiles \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 relations \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 rules \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 tenants \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 widgets \u2514\u2500\u2500 ...","title":"Configuration"},{"location":"configuration/#thingsboard-auto-configuration","text":"The library provides mean to streamline ThingsBoard configuration (e.g. devices, rule chains, dashboards). Instead of configuring ThingsBoard separately, it allows doing so within the tb-utils application itself. This provides multiple benefits: Reduced deployment effort Streamlined maintenance path, where a new release of an application will also roll out necessary TB configuration changes (e.g. schema, rule-chain or dashboard improvements) The API also supports merging configuration changes into a running system by There are 2 dedicated functions, that a developer can instrument to enable application backup and restore. Backup - Download ThingsBoard entities and save them as json files Upload - Restore previously persisted entities Backup and restore are available for all major TB entity types. See here for a fully worked out example.","title":"ThingsBoard Auto-Configuration"},{"location":"configuration/#backup","text":"This is typically performed after TB has been configured via the web UI, and all relevant settings should be packaged for deployment. TbBackup backup = new TbBackup ( restClient ); TbConfigPaths configPaths = new TbConfigPaths ( \"tbconfig\" ); backup . getDeviceProfile (). save ( System . getenv ( \"DEVICE_PROFILE\" ), configPaths . profilesPath ); backup . getRuleChain (). save ( \"Vibration Root Rule Chain\" , configPaths . rulesPath ); backup . getWidgetBundle (). save ( \"Systema Widgets\" , configPaths . widgetsBundlePath ); backup . getWidget (). save ( \"Systema Widgets\" , \"Change Device\" , configPaths . widgetsPath ); backup . getDashboard (). save ( \"Vibration CM\" , configPaths . dashboardsPath ); This will store the entities as json in a user-defined resource directory within the application. So essentially, the user only needs to declare which entities belong to the application and should be persisted.","title":"Backup"},{"location":"configuration/#upload","text":"Later on during deployment or application update, the persisted entities can be restored/updated using an inverse procedure: ConfigUploader uploader = new ConfigUploader ( client ); uploader . getDeviceProfile (). loadAll ( \"path/to/my-device-profile.json\" ); uploader . getDashboard (). load ( \"path/to/my-dashboard.json\" );","title":"Upload"},{"location":"configuration/#entity-path-model","text":"The config files that tb-utils can deal with are json files created either via the ThingsBoard web UI export functionality or by using the tb-utils backup feature. For easier config file handling, there is a utility class structuring the config files in the following way (or a subset thereof): var configPaths = new TbConfigPaths ( \"config/root/dir/\" ); This would create a file structure like this: config/root/dir/ \u251c\u2500\u2500 assets \u2502 \u2514\u2500\u2500 xxx.json \u251c\u2500\u2500 bundles \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 customers \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 dashboards \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 devices \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 profiles \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 relations \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 rules \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 tenants \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 widgets \u2514\u2500\u2500 ...","title":"Entity Path Model"},{"location":"connectivity/","text":"Improved Connectivity Extended Rest Client The ExtRestClient is a wrapper around ThingsBoard Java Client to extend functionality. Here are some highlights. Connect to ThingsBoard and obtain information of a certain device (Java example): var client = new ExtRestClient ( url , user , password ); var device = client . getOrCreateDevice ( \"myDevice\" , \"myProfile\" ); Find all devices of a certain profile (Java example): List < Device > devices = client . getDevicesByProfile ( \"myProfile\" ); Read or update device attributes or telemetry (Java example): client . getAttribute ( device . getId (), Scope . CLIENT_SCOPE , \"myAttribute\" ); client . saveAttribute ( device . getId (), Scope . SERVER_SCOPE , \"myAttribute\" , 42 ); client . sendTelemetry ( device . getId (), \"temperature\" , 47.11 ); Subscribe to attribute updates, filtered by names (Kotlin example): client . subscribeToWS ( device . id , SubscriptionType . SHARED_SCOPE , listOf ( \"temperature\" , \"humidity\" )) { changes -> changes . forEach { println ( \"Received attribute update: $ it \" ) } } ... or in Java: WsSubscribeKt . subscribeToWS ( client , device . getId (), SubscriptionType . SHARED_SCOPE , List . of ( \"temperature\" , \"humidity\" ), ( changes ) -> { changes . forEach (( change ) -> System . out . println ( \"Received attribute update: \" + change )); return Unit . INSTANCE ; // ~void; required for Java-Kotlin compatibility }); Clear any active alarm or create a new alarm, if none of the same type is currently active (Java example): client . newAlarmIfNotActive ( device . getId (), device . getName (), \"myAlarmType\" , AlarmSeverity . WARNING ); client . clearAlarmIfActive ( device . getId (), device . getName (), \"myAlarmType\" ); Store attribute changes as telemetry. Each attribute update, that is received by the iot application, will be sent to ThingsBoard as a telemetry item, named according to the attribute name and scope. E.g. each update of a status attribute in the SHARED_SCOPE would now be stored as attrscope__SHARED_SCOPE__name__status telemetry value. (Kotlin example): client . saveAttributeChanges ( device . id ) Mqtt Client The DeviceMqttClient allows to send and receive data to/from ThingsBoard via MQTT.","title":"Connectivity"},{"location":"connectivity/#improved-connectivity","text":"","title":"Improved Connectivity"},{"location":"connectivity/#extended-rest-client","text":"The ExtRestClient is a wrapper around ThingsBoard Java Client to extend functionality. Here are some highlights. Connect to ThingsBoard and obtain information of a certain device (Java example): var client = new ExtRestClient ( url , user , password ); var device = client . getOrCreateDevice ( \"myDevice\" , \"myProfile\" ); Find all devices of a certain profile (Java example): List < Device > devices = client . getDevicesByProfile ( \"myProfile\" ); Read or update device attributes or telemetry (Java example): client . getAttribute ( device . getId (), Scope . CLIENT_SCOPE , \"myAttribute\" ); client . saveAttribute ( device . getId (), Scope . SERVER_SCOPE , \"myAttribute\" , 42 ); client . sendTelemetry ( device . getId (), \"temperature\" , 47.11 ); Subscribe to attribute updates, filtered by names (Kotlin example): client . subscribeToWS ( device . id , SubscriptionType . SHARED_SCOPE , listOf ( \"temperature\" , \"humidity\" )) { changes -> changes . forEach { println ( \"Received attribute update: $ it \" ) } } ... or in Java: WsSubscribeKt . subscribeToWS ( client , device . getId (), SubscriptionType . SHARED_SCOPE , List . of ( \"temperature\" , \"humidity\" ), ( changes ) -> { changes . forEach (( change ) -> System . out . println ( \"Received attribute update: \" + change )); return Unit . INSTANCE ; // ~void; required for Java-Kotlin compatibility }); Clear any active alarm or create a new alarm, if none of the same type is currently active (Java example): client . newAlarmIfNotActive ( device . getId (), device . getName (), \"myAlarmType\" , AlarmSeverity . WARNING ); client . clearAlarmIfActive ( device . getId (), device . getName (), \"myAlarmType\" ); Store attribute changes as telemetry. Each attribute update, that is received by the iot application, will be sent to ThingsBoard as a telemetry item, named according to the attribute name and scope. E.g. each update of a status attribute in the SHARED_SCOPE would now be stored as attrscope__SHARED_SCOPE__name__status telemetry value. (Kotlin example): client . saveAttributeChanges ( device . id )","title":"Extended Rest Client"},{"location":"connectivity/#mqtt-client","text":"The DeviceMqttClient allows to send and receive data to/from ThingsBoard via MQTT.","title":"Mqtt Client"},{"location":"examples/","text":"There's nothing more intriguing than a good example. Vibration Monitoring In the Vibration Monitoring Demo the following API capabilities are demonstrated Automatic ThingsBoard configuration updates Automatic device discovery Subscribing to and acting upon ThingsBoard device attribute and telemetry updates Device Alarm Demonstrated capabilities Device lookup and creation Extended Rest client package com.systema.eia.iot.tb.examples import com.systema.eia.iot.tb.clients.ExtRestClient import org.thingsboard.server.common.data.alarm.Alarm import org.thingsboard.server.common.data.alarm.AlarmSeverity import org.thingsboard.server.common.data.alarm.AlarmStatus val restClient = ExtRestClient ( System . getenv ( \"TB_URL\" ), System . getenv ( \"TB_USER\" ), System . getenv ( \"TB_PW\" ) ) val device = restClient . getOrCreateDevice ( \"test_alarm_device\" ) val alarm = Alarm (). apply { type = \"test_alarm\" originator = device . id severity = AlarmSeverity . MAJOR status = AlarmStatus . ACTIVE_UNACK } println ( \"saving alarm\" ) restClient . createAlarm ( alarm )","title":"Examples"},{"location":"examples/#vibration-monitoring","text":"In the Vibration Monitoring Demo the following API capabilities are demonstrated Automatic ThingsBoard configuration updates Automatic device discovery Subscribing to and acting upon ThingsBoard device attribute and telemetry updates","title":"Vibration Monitoring"},{"location":"examples/#device-alarm","text":"Demonstrated capabilities Device lookup and creation Extended Rest client package com.systema.eia.iot.tb.examples import com.systema.eia.iot.tb.clients.ExtRestClient import org.thingsboard.server.common.data.alarm.Alarm import org.thingsboard.server.common.data.alarm.AlarmSeverity import org.thingsboard.server.common.data.alarm.AlarmStatus val restClient = ExtRestClient ( System . getenv ( \"TB_URL\" ), System . getenv ( \"TB_USER\" ), System . getenv ( \"TB_PW\" ) ) val device = restClient . getOrCreateDevice ( \"test_alarm_device\" ) val alarm = Alarm (). apply { type = \"test_alarm\" originator = device . id severity = AlarmSeverity . MAJOR status = AlarmStatus . ACTIVE_UNACK } println ( \"saving alarm\" ) restClient . createAlarm ( alarm )","title":"Device Alarm"},{"location":"faq/","text":"F.A.Q. How to disable verbose Spring RestTemplate logging? Wanna get rid of verbose log entries on each REST request? In the project where you're using tb-utils , just create a file src/main/resources/application.properties with this content: logging.level.org.springframework = OFF logging.level.root = OFF How to run the tests? A running TB instance with is required, which must be exposed via 2 environment variables TB_URL - tb host TB_MQTT_URL - tb mqtt broker This TB instance must have default username (tenant@thingsboard.org) and pw (tenant) configured. To start a local ThingsBoard instance (for details, see https://thingsboard.io/docs/user-guide/install/docker ): docker-compose up -d mytb To run the tests: # change if necessary export TB_URL = http://localhost:8080 export TB_MQTT_URL = http://localhost:1884 ./gradlew test How to release a new version? See release.md","title":"FAQ"},{"location":"faq/#faq","text":"","title":"F.A.Q."},{"location":"faq/#how-to-disable-verbose-spring-resttemplate-logging","text":"Wanna get rid of verbose log entries on each REST request? In the project where you're using tb-utils , just create a file src/main/resources/application.properties with this content: logging.level.org.springframework = OFF logging.level.root = OFF","title":"How to disable verbose Spring RestTemplate logging?"},{"location":"faq/#how-to-run-the-tests","text":"A running TB instance with is required, which must be exposed via 2 environment variables TB_URL - tb host TB_MQTT_URL - tb mqtt broker This TB instance must have default username (tenant@thingsboard.org) and pw (tenant) configured. To start a local ThingsBoard instance (for details, see https://thingsboard.io/docs/user-guide/install/docker ): docker-compose up -d mytb To run the tests: # change if necessary export TB_URL = http://localhost:8080 export TB_MQTT_URL = http://localhost:1884 ./gradlew test","title":"How to run the  tests?"},{"location":"faq/#how-to-release-a-new-version","text":"See release.md","title":"How to release a new version?"},{"location":"misc/","text":"User Configuration Quite often, the default tenant and sysadmin passwords are used. tb-utils provides a simple means to set them programmatically to improve the security of a TB deployment. // Configure thingsboard application user (first run only) UserConfigurator . updateDefaultAdminUserPassword ( tbURL , TBUTILS_DEMO_SYSADMIN_PW ) UserConfigurator . updateDefaultTenantUserPassword ( tbURL , TBUTILS_DEMO_TENANT_PW ) After a deployment has been secured, tb-utils allows creating new application user programmatically. By doing so an application can bootstrap a tenant configuration without additional (manual) intervention. UserConfigurator . userConfig ( url , // url of TB TBUTILS_DEMO_SYSADMIN_PW , // sysadmin password \"me@my.org\" , // user email \"sErcEt\" , // user password \"My Tenant\" // user tenant ) Statistics The stats package provides utilities to process device telemetry data. MovingAverage - moving average with configurable history window. Misc As usual, there is a utils Package including miscellaneous utility classes.","title":"Misc"},{"location":"misc/#user-configuration","text":"Quite often, the default tenant and sysadmin passwords are used. tb-utils provides a simple means to set them programmatically to improve the security of a TB deployment. // Configure thingsboard application user (first run only) UserConfigurator . updateDefaultAdminUserPassword ( tbURL , TBUTILS_DEMO_SYSADMIN_PW ) UserConfigurator . updateDefaultTenantUserPassword ( tbURL , TBUTILS_DEMO_TENANT_PW ) After a deployment has been secured, tb-utils allows creating new application user programmatically. By doing so an application can bootstrap a tenant configuration without additional (manual) intervention. UserConfigurator . userConfig ( url , // url of TB TBUTILS_DEMO_SYSADMIN_PW , // sysadmin password \"me@my.org\" , // user email \"sErcEt\" , // user password \"My Tenant\" // user tenant )","title":"User Configuration"},{"location":"misc/#statistics","text":"The stats package provides utilities to process device telemetry data. MovingAverage - moving average with configurable history window.","title":"Statistics"},{"location":"misc/#misc","text":"As usual, there is a utils Package including miscellaneous utility classes.","title":"Misc"},{"location":"setup/","text":"Installation tbutils requires Java11 or higher. How to use? tb-utils is released to maven-central. To add it to your project, simply add is dependency to your gradle or maven project definition. repositories { mavenCentral() maven { url = uri(\"https://repo.thingsboard.io/artifactory/libs-release-public\") } maven { url = uri(\"https://maven.pkg.github.com/systema/tbutils\") credentials { username = project.findProperty(\"gpr.user\") as String? ?: System.getenv(\"GH_USER\") password = project.findProperty(\"gpr.key\") as String? ?: System.getenv(\"GH_TOKEN\") } } } dependencies { implementation \"com.systema.eia.iot:tbutils:2.0.2\" } Builds are hosted on maven-central supported by the great folks at sonatype . Jitpack Integration You can also use JitPack with Maven or Gradle to include the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.systema.eia.iot:tbutils:-SNAPSHOT' } How to build it from sources? To build and install it into your local maven cache, simply clone the repo and run ./gradlew install Clearly, we could also build jar and use it directly with ./gradlew jar but this is not recommended.","title":"Setup"},{"location":"setup/#installation","text":"tbutils requires Java11 or higher.","title":"Installation"},{"location":"setup/#how-to-use","text":"tb-utils is released to maven-central. To add it to your project, simply add is dependency to your gradle or maven project definition. repositories { mavenCentral() maven { url = uri(\"https://repo.thingsboard.io/artifactory/libs-release-public\") } maven { url = uri(\"https://maven.pkg.github.com/systema/tbutils\") credentials { username = project.findProperty(\"gpr.user\") as String? ?: System.getenv(\"GH_USER\") password = project.findProperty(\"gpr.key\") as String? ?: System.getenv(\"GH_TOKEN\") } } } dependencies { implementation \"com.systema.eia.iot:tbutils:2.0.2\" } Builds are hosted on maven-central supported by the great folks at sonatype .","title":"How to use?"},{"location":"setup/#jitpack-integration","text":"You can also use JitPack with Maven or Gradle to include the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.systema.eia.iot:tbutils:-SNAPSHOT' }","title":"Jitpack Integration"},{"location":"setup/#how-to-build-it-from-sources","text":"To build and install it into your local maven cache, simply clone the repo and run ./gradlew install Clearly, we could also build jar and use it directly with ./gradlew jar but this is not recommended.","title":"How to build it from sources?"}]}